/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Create a tensor buffer from a Float32Array or Buffer
 *
 * # Arguments
 *
 * * `data` - Buffer containing f32 data
 * * `shape` - Dimensions of the tensor
 *
 * # Example
 *
 * ```javascript
 * const buffer = Buffer.from(new Float32Array([1, 2, 3, 4]).buffer);
 * const tensor = createTensorBuffer(buffer, [2, 2]);
 * ```
 */
export declare function createTensorBuffer(
  data: Buffer,
  shape: Array<number>,
): TensorBuffer;
/**
 * Create a tensor from a buffer (zero-copy)
 *
 * # Arguments
 *
 * * `buffer` - Raw buffer containing tensor data
 * * `shape` - Dimensions of the tensor
 * * `dtype` - Data type: "f32", "f64", "i32", "i64"
 *
 * # Example
 *
 * ```javascript
 * const buffer = Buffer.from(new Float32Array([1, 2, 3, 4]).buffer);
 * const tensor = tensorFromBuffer(buffer, [2, 2], 'f32');
 * ```
 */
export declare function tensorFromBuffer(
  buffer: Buffer,
  shape: Array<number>,
  dtype: string,
): TensorBuffer;
/**
 * Concatenate multiple tensor buffers along a dimension (creates a copy)
 *
 * # Arguments
 *
 * * `tensors` - Array of tensor buffers to concatenate
 * * `axis` - Dimension along which to concatenate
 *
 * # Example
 *
 * ```javascript
 * const t1 = createTensorBuffer([1, 2], [2]);
 * const t2 = createTensorBuffer([3, 4], [2]);
 * const result = concatenateTensors([t1, t2], 0); // [1, 2, 3, 4] with shape [4]
 * ```
 */
export declare function concatenateTensors(
  tensors: Array<TensorBuffer>,
  axis: number,
): TensorBuffer;
/**
 * Split a tensor buffer into multiple tensors (creates copies)
 *
 * # Arguments
 *
 * * `tensor` - Tensor buffer to split
 * * `num_splits` - Number of equal-sized splits
 *
 * # Example
 *
 * ```javascript
 * const tensor = createTensorBuffer([1, 2, 3, 4, 5, 6], [6]);
 * const [t1, t2, t3] = splitTensor(tensor, 3); // Each has shape [2]
 * ```
 */
export declare function splitTensor(
  tensor: TensorBuffer,
  numSplits: number,
): Array<TensorBuffer>;
/** Coordinator configuration for JavaScript */
export interface CoordinatorConfig {
  /** Minimum number of nodes required to start a training round */
  minNodesForRound: number;
  /** Heartbeat timeout in milliseconds */
  heartbeatTimeoutMs: number;
  /** Task timeout in milliseconds */
  taskTimeoutMs: number;
  /** Consensus threshold (0.0 - 1.0) */
  consensusThreshold: number;
}
/** Coordinator status for JavaScript */
export interface CoordinatorStatusJs {
  /** Number of active training nodes */
  activeNodes: number;
  /** Number of pending training tasks */
  pendingTasks: number;
  /** Current training round */
  currentRound: number;
  /** Model version */
  modelVersion: number;
}
/** Training configuration for JavaScript */
export interface TrainingConfigJs {
  /** Batch size for training */
  batchSize: number;
  /** Learning rate */
  learningRate: number;
  /** Number of epochs to train */
  epochs: number;
  /** Optimizer type: "sgd", "adam", "adamw" */
  optimizer: string;
  /** Optimizer-specific parameters (e.g., momentum, beta1, beta2) */
  optimizerParams?: Record<string, number>;
  /** Aggregation strategy: "fedavg", "secure", "trimmed_mean", "krum" */
  aggregationStrategy: string;
}
/** Training metrics returned to JavaScript */
export interface TrainingMetricsJs {
  /** Training loss */
  loss: number;
  /** Training accuracy (0-1) */
  accuracy: number;
  /** Number of samples processed */
  samplesProcessed: number;
  /** Computation time in milliseconds */
  computationTimeMs: number;
}
/** Gradient update data for JavaScript */
export interface GradientUpdateJs {
  /** Node identifier */
  nodeId: string;
  /** Model version */
  modelVersion: number;
  /** Training round */
  round: number;
  /** Training metrics */
  metrics: TrainingMetricsJs;
  /** Timestamp (Unix epoch milliseconds) */
  timestamp: number;
}
/** Node information for JavaScript */
export interface NodeInfoJs {
  /** Unique node identifier */
  nodeId: string;
  /** Node type (e.g., "trainer", "coordinator") */
  nodeType: string;
  /** Last heartbeat timestamp (Unix epoch milliseconds) */
  lastHeartbeat: number;
  /** Reliability score (0.0 - 1.0) */
  reliabilityScore: number;
}
/** Optimizer type for JavaScript */
export interface OptimizerTypeJs {
  /** Optimizer name: "sgd", "adam", "adamw" */
  optimizerType: string;
  /** Optimizer-specific parameters */
  params?: Record<string, number>;
}
/** Aggregation strategy for JavaScript */
export interface AggregationStrategyJs {
  /** Strategy name: "fedavg", "secure", "trimmed_mean", "krum" */
  strategyType: string;
  /** Strategy-specific parameters */
  params?: Record<string, number>;
}
/** Model metadata for JavaScript */
export interface ModelMetadataJs {
  /** Model identifier */
  id: string;
  /** Model version */
  version: number;
  /** Model architecture (e.g., "ResNet50", "BERT") */
  architecture: string;
  /** Number of parameters in the model */
  parametersCount: number;
  /** Creation timestamp (Unix epoch milliseconds) */
  createdAt: number;
  /** Last update timestamp (Unix epoch milliseconds) */
  updatedAt: number;
}
/** Create a default training configuration */
export declare function createDefaultTrainingConfig(): TrainingConfigJs;
/** Create a default coordinator configuration */
export declare function createDefaultCoordinatorConfig(): CoordinatorConfig;
/** Validate node ID format */
export declare function validateNodeId(nodeId: string): boolean;
/** Generate a unique node ID */
export declare function generateNodeId(
  prefix?: string | undefined | null,
): string;
/** Initialize the Prime ML NAPI module */
export declare function init(): string;
/** Get the version of the Prime ML NAPI bindings */
export declare function version(): string;
/**
 * Tensor buffer wrapper for zero-copy operations
 *
 * Wraps napi::Buffer to provide type-safe tensor operations with
 * zero-copy semantics for maximum performance.
 */
export declare class TensorBuffer {
  /**
   * Create a new tensor buffer from raw data
   *
   * # Arguments
   *
   * * `buffer` - Raw buffer containing tensor data
   * * `shape` - Dimensions of the tensor
   * * `dtype` - Data type: "f32", "f64", "i32", "i64"
   *
   * # Example
   *
   * ```javascript
   * const buffer = Buffer.from(new Float32Array([1, 2, 3, 4]).buffer);
   * const tensor = new TensorBuffer(buffer, [2, 2], 'f32');
   * ```
   */
  constructor(buffer: Buffer, shape: Array<number>, dtype: string);
  /** Get the underlying buffer (zero-copy) */
  get buffer(): Buffer;
  /** Get the tensor shape */
  get shape(): Array<number>;
  /** Get the data type */
  get dtype(): string;
  /** Get the total number of elements */
  numElements(): number;
  /** Get the buffer size in bytes */
  byteSize(): number;
  /**
   * Convert to a flat f32 array (creates a copy)
   *
   * Note: This creates a copy of the data. Use buffer() for zero-copy access.
   */
  toF32Array(): Array<number>;
  /**
   * Convert to a flat f64 array (creates a copy)
   *
   * Note: This creates a copy of the data. Use buffer() for zero-copy access.
   */
  toF64Array(): Array<number>;
  /**
   * Reshape the tensor (zero-copy)
   *
   * Creates a new view of the same data with a different shape.
   * The total number of elements must remain the same.
   */
  reshape(newShape: Array<number>): TensorBuffer;
  /** Clone the tensor buffer (creates a copy) */
  cloneTensor(): TensorBuffer;
}
/**
 * Federated learning coordinator
 *
 * Manages distributed training coordination, node registration, and consensus.
 * The coordinator orchestrates training rounds across multiple nodes and ensures
 * proper synchronization and model updates.
 */
export declare class Coordinator {
  /**
   * Create a new coordinator
   *
   * # Arguments
   *
   * * `node_id` - Unique identifier for this coordinator
   * * `config` - Optional coordinator configuration (uses defaults if not provided)
   *
   * # Example
   *
   * ```javascript
   * const coordinator = new Coordinator('coordinator-1', {
   *   minNodesForRound: 5,
   *   heartbeatTimeoutMs: 10000,
   *   taskTimeoutMs: 120000,
   *   consensusThreshold: 0.75
   * });
   * ```
   */
  constructor(nodeId: string, config?: CoordinatorConfig | undefined | null);
  /**
   * Initialize the coordinator
   *
   * Sets up the coordinator and prepares it to accept node registrations
   * and coordinate training rounds.
   *
   * # Example
   *
   * ```javascript
   * await coordinator.init();
   * ```
   */
  init(): Promise<void>;
  /**
   * Register a new training node
   *
   * Adds a training node to the coordinator's active node registry.
   * Nodes must be registered before they can participate in training rounds.
   *
   * # Arguments
   *
   * * `node_info` - Information about the node to register
   *
   * # Example
   *
   * ```javascript
   * await coordinator.registerNode({
   *   nodeId: 'node-1',
   *   nodeType: 'trainer',
   *   lastHeartbeat: Date.now(),
   *   reliabilityScore: 0.95
   * });
   * ```
   */
  registerNode(nodeInfo: NodeInfoJs): Promise<void>;
  /**
   * Start a new training round
   *
   * Initiates a new federated learning training round. This coordinates
   * all registered nodes to perform local training and gradient updates.
   *
   * # Returns
   *
   * The round number that was started
   *
   * # Example
   *
   * ```javascript
   * const roundNumber = await coordinator.startTraining();
   * console.log(`Started training round ${roundNumber}`);
   * ```
   */
  startTraining(): Promise<number>;
  /**
   * Get training progress for the current round
   *
   * Returns detailed information about the current training round's progress,
   * including how many nodes have completed training and reported gradients.
   *
   * # Returns
   *
   * Progress information including completion percentage and node status
   *
   * # Example
   *
   * ```javascript
   * const progress = await coordinator.getProgress();
   * console.log(`Training ${progress.completionPercent}% complete`);
   * console.log(`${progress.completedNodes}/${progress.totalNodes} nodes finished`);
   * ```
   */
  getProgress(): Promise<any>;
  /**
   * Get coordinator status
   *
   * Returns comprehensive status information about the coordinator including
   * active nodes, pending tasks, and current round information.
   *
   * # Returns
   *
   * Coordinator status object
   *
   * # Example
   *
   * ```javascript
   * const status = await coordinator.getStatus();
   * console.log(`Active nodes: ${status.activeNodes}`);
   * console.log(`Current round: ${status.currentRound}`);
   * ```
   */
  getStatus(): Promise<CoordinatorStatusJs>;
  /**
   * Stop the coordinator and clean up resources
   *
   * Gracefully shuts down the coordinator, notifying all nodes and
   * cleaning up network connections.
   *
   * # Example
   *
   * ```javascript
   * await coordinator.stop();
   * ```
   */
  stop(): Promise<void>;
  /** Get the coordinator's node ID */
  get nodeId(): string;
  /** Get the current round number */
  get currentRound(): Promise<number>;
  /** Get the current model version */
  get modelVersion(): Promise<number>;
}
/**
 * Training node for distributed federated learning
 *
 * Represents a single training node in a federated learning system.
 * Provides methods for training initialization, epoch execution, and gradient aggregation.
 */
export declare class TrainingNode {
  /**
   * Create a new training node
   *
   * # Arguments
   *
   * * `node_id` - Unique identifier for this training node
   *
   * # Example
   *
   * ```javascript
   * const node = new TrainingNode('node-1');
   * ```
   */
  constructor(nodeId: string);
  /**
   * Initialize training with the given configuration
   *
   * Sets up the training node with specified hyperparameters and prepares
   * for training execution.
   *
   * # Arguments
   *
   * * `config` - Training configuration including batch size, learning rate, etc.
   *
   * # Example
   *
   * ```javascript
   * await node.initTraining({
   *   batchSize: 32,
   *   learningRate: 0.001,
   *   epochs: 10,
   *   optimizer: 'adam',
   *   aggregationStrategy: 'fedavg'
   * });
   * ```
   */
  initTraining(config: TrainingConfigJs): Promise<void>;
  /**
   * Train for one epoch
   *
   * Executes one complete training epoch and returns training metrics.
   * This operation processes all training data once.
   *
   * # Returns
   *
   * Training metrics including loss, accuracy, and timing information
   *
   * # Example
   *
   * ```javascript
   * const metrics = await node.trainEpoch();
   * console.log(`Loss: ${metrics.loss}, Accuracy: ${metrics.accuracy}`);
   * ```
   */
  trainEpoch(): Promise<TrainingMetricsJs>;
  /**
   * Aggregate gradients from multiple training nodes
   *
   * Performs parallel gradient aggregation using zero-copy operations.
   * Supports various aggregation strategies (FedAvg, secure aggregation, etc.)
   *
   * # Arguments
   *
   * * `gradients` - Array of gradient buffers from different nodes
   *
   * # Returns
   *
   * Aggregated gradient buffer
   *
   * # Example
   *
   * ```javascript
   * const grad1 = await node1.getGradients();
   * const grad2 = await node2.getGradients();
   * const aggregated = await coordinator.aggregateGradients([grad1, grad2]);
   * ```
   */
  aggregateGradients(gradients: Array<Buffer>): Promise<Buffer>;
  /**
   * Get current training status
   *
   * Returns detailed information about the training node's current state.
   *
   * # Returns
   *
   * Object containing node_id, current_epoch, and is_training flag
   */
  getStatus(): any;
  /** Get the node's unique identifier */
  get nodeId(): string;
  /** Get the current epoch number */
  get currentEpoch(): Promise<number>;
}
